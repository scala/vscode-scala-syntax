{
  "$schema": "http://json-schema.org/draft-06/schema#",
  "title": "tmLanguage",
  "description": "Schema for language grammar description files in Textmate and compatible editors. See https://github.com/Septh/tmlanguage/blob/master/tmLanguage.schema.json",
  "type": "object",
  "properties": {
    "scopeName": {
      "description": "This should be a unique name for the grammar, following the convention of being a dot-separated name where each new (left-most) part specializes the name. Normally it would be a two-part name where the first is either `text` or `source` and the second is the name of the language or document type. But if you are specializing an existing type, you probably want to derive the name from the type you are specializing. For example Markdown is `text.html.markdown` and Ruby on Rails (rhtml files) is `text.html.rails`. The advantage of deriving it from (in this case) `text.html` is that everything which works in the `text.html` scope will also work in the `text.html.«something»` scope (but with a lower precedence than something specifically targeting `text.html.«something»`).",
      "type": "string",
      "pattern": "^[\\w$@][\\w\\-$@]*(?:\\.[\\w$@][\\w\\-$@]*)*$"
    },
    "fileTypes": {
      "description": "An array of file type extensions that the grammar should (by default) be used with.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "firstLineMatch": {
      "description": "A regular expression which is matched against the first line of the document when it is first loaded. If it matches, the grammar is used for the document.",
      "type": "string"
    },
    "uuid": {
      "description": "When the grammer is part of a larger bundle (ie., grammer + theme + whatever), the uuid helps classify which file is a part of which bundle.",
      "type": "string"
    },
    "foldingStartMarker": {
      "description": "Regular expression that lines (in the document) are matched against. If a line matches the pattern, it starts a foldable block.",
      "type": "string"
    },
    "foldingStopMarker": {
      "description": "Regular expressions that lines (in the document) are matched against. If a line matches pattern, it ends a foldable block.",
      "type": "string"
    },
    "patterns": {
      "description": "An array with the actual rules used to parse the document.",
      "$ref": "#/definitions/patterns"
    },
    "repository": {
      "description": "A dictionary (i.e. key/value pairs) of rules which can be included from other places in the grammar. The key is the name of the rule and the value is the actual rule.",
      "$ref": "#/definitions/repository"
    },
    "injectionSelector": {
      "description": "The key is a scope selector that specifies which scope(s) the current grammar should be injected in.",
      "type": "string"
    },
    "injections": {
      "description": "[VS Code only, it seems] A dictionary (i.e. key/value pairs) of rules which will be injected into an existing grammar. The key is the target scope of the parent grammar and the value is the actual rule to inject.",
      "$ref": "#/definitions/repository"
    }
  },
  "required": [
    "scopeName",
    "patterns"
  ],
  "dependencies": {
    "foldingStartMarker": [
      "foldingStopMarker"
    ],
    "foldingStopMarker": [
      "foldingStartMarker"
    ],
    "injections": {
      "not": {
        "required": [
          "injectionSelector"
        ]
      }
    }
  },
  "additionalProperties": true,
  "definitions": {
    "boolean-or-integer": {
      "oneOf": [
        {
          "type": "boolean"
        },
        {
          "type": "number",
          "enum": [
            0,
            1
          ]
        }
      ]
    },
    "patterns": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/rule"
      }
    },
    "repository": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/rule"
      }
    },
    "name": {
      "type": "string",
      "pattern": "^[\\w$@][\\w\\-$@]*(?:(?:\\.| )[\\w$@][\\w\\-$@]*)*$"
    },
    "captures": {
      "type": "object",
      "patternProperties": {
        "^[0-9]+$": {
          "type": "object",
          "properties": {
            "name": {
              "description": "The scope name which gets assigned to the capture matched. This should generally be derived from one of the standard names.",
              "type": "string"
            },
            "patterns": {
              "description": "Yes, captures can be further matched against additional patterns, too.",
              "$ref": "#/definitions/patterns"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "rule": {
      "type": "object",
      "properties": {
        "comment": {
          "description": "A generic text used to describe or explain the rule.",
          "type": "string"
        },
        "name": {
          "description": "The scope name which gets assigned to the capture matched. This should generally be derived from one of the standard names.",
          "type": "string"
        },
        "disabled": {
          "description": "Marks the rule as disabled. A disabled rule should be ignored by the tokenization engine.",
          "$ref": "#/definitions/boolean-or-integer"
        },
        "include": {
          "description": "This key allows you to reference a different language (value == scope name), recursively reference the grammar itself (value == \"$self\") or a rule declared in this file’s repository (value starts with a pound (#) sign).",
          "type": "string"
        },
        "match": {
          "description": "A regular expression which is used to identify the portion of text to which the name should be assigned.",
          "type": "string"
        },
        "begin": {
          "description": "The `begin` key is a regular expression pattern that allows matches which span several lines. Captures from the `begin` pattern can be referenced in the corresponding `end` or `while` pattern by using normal regular expression back-references, eg. `\\1$`.",
          "type": "string"
        },
        "end": {
          "description": "A regular expression pattern that, when matched, ends the multi-line block started by the `begin` key.",
          "type": "string"
        },
        "while": {
          "description": "A regular expression pattern that, while matched, continues the multi-line block started by the `begin` key.",
          "type": "string"
        },
        "applyEndPatternLast": {
          "description": "Tests the `end` pattern after the other patterns in the `begin`/`end` block.",
          "$ref": "#/definitions/boolean-or-integer"
        },
        "contentName": {
          "description": "This key is similar to the `name` key but it only assigns the name to the text between what is matched by the `begin`/`end` patterns.",
          "type": "string"
        },
        "captures": {
          "description": "This key allows you to assign attributes to the captures of the `match`, `begin`, `end` and `while`patterns. Using the `captures` key for a `begin`/`end` rule is short-hand for giving both `beginCaptures` and `endCaptures` with same values. The value of this key is a dictionary with the key being the capture number and the value being a dictionary of attributes to assign to the captured text.",
          "$ref": "#/definitions/captures"
        },
        "beginCaptures": {
          "description": "This key allows you to assign attributes to the captures of the `begin` pattern. The value of this key is a dictionary with the key being the capture number and the value being a dictionary of attributes to assign to the captured text.",
          "$ref": "#/definitions/captures"
        },
        "endCaptures": {
          "description": "This key allows you to assign attributes to the captures of the `end` pattern. The value of this key is a dictionary with the key being the capture number and the value being a dictionary of attributes to assign to the captured text.",
          "$ref": "#/definitions/captures"
        },
        "whileCaptures": {
          "description": "This key allows you to assign attributes to the captures of the `while` pattern. The value of this key is a dictionary with the key being the capture number and the value being a dictionary of attributes to assign to the captured text.",
          "$ref": "#/definitions/captures"
        },
        "patterns": {
          "description": "An array with the actual rules used to parse the matched content.",
          "$ref": "#/definitions/patterns"
        },
        "repository": {
          "description": "A dictionary (i.e. key/value pairs) of rules which can be included from other places in the grammar. The key is the name of the rule and the value is the actual rule.",
          "$ref": "#/definitions/repository"
        }
      },
      "additionalProperties": false,
      "dependencies": {
        "include": {
          "allOf": [
            {
              "not": {
                "required": [
                  "match"
                ]
              }
            },
            {
              "not": {
                "required": [
                  "begin"
                ]
              }
            }
          ]
        },
        "match": {
          "not": {
            "required": [
              "begin"
            ]
          }
        },
        "begin": {
          "oneOf": [
            {
              "required": [
                "end"
              ]
            },
            {
              "required": [
                "while"
              ]
            }
          ]
        },
        "end": [
          "begin"
        ],
        "while": [
          "begin"
        ],
        "applyEndPatternLast": [
          "begin"
        ],
        "captures": {
          "oneOf": [
            {
              "required": [
                "match"
              ]
            },
            {
              "required": [
                "begin"
              ]
            }
          ]
        },
        "beginCaptures": [
          "begin"
        ],
        "endCaptures": [
          "end"
        ],
        "whileCaptures": [
          "while"
        ]
      }
    }
  }
}